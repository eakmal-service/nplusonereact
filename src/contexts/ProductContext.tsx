"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { supabase } from '@/lib/supabaseClient';
import { Product } from '@/utils/productUtils'; // Keeping the type definition

// Define context type
interface ProductContextType {
  products: Product[];
  isLoading: boolean;
  saveNewProduct: (product: any) => Promise<boolean>;
  updateExistingProduct: (product: Product) => Promise<boolean>;
  updateStatus: (id: number, status: 'active' | 'inactive' | 'draft') => Promise<boolean>;
  updateStock: (id: number, newStock: number) => Promise<boolean>;
  removeProduct: (id: number) => Promise<boolean>;
  refreshProducts: () => Promise<void>;
  getProductsByCategory: (category: string) => Product[];
  getActiveProductsByCategory: (category: string) => Product[];
}

// Create context with default values
const ProductContext = createContext<ProductContextType>({
  products: [],
  isLoading: true,
  saveNewProduct: async () => false,
  updateExistingProduct: async () => false,
  updateStatus: async () => false,
  updateStock: async () => false,
  removeProduct: async () => false,
  refreshProducts: async () => { },
  getProductsByCategory: () => [],
  getActiveProductsByCategory: () => [],
});

// Provider component
export const ProductProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch products from Supabase
  const refreshProducts = async () => {
    setIsLoading(true);
    try {
      // 1. Fetch from Supabase
      const { data, error } = await supabase
        .from('products')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching products:', error);
        // Fallback or empty logic could go here
      } else if (data) {
        // Map Supabase data to our Product interface
        // Note: Supabase columns might need mapping if they differ from Product interface
        // Assuming the schema matches essentially.
        const mappedProducts: Product[] = data.map((p: any) => ({
          id: p.id, // Assuming ID is numeric in Supabase or we handle string IDs locally?
          // NOTE: If Supabase IDs are UUIDs (strings), we might have type issues if Product.id is number.
          // Let's assume for now we might need to handle ID types carefully.
          // The SQL schema created `products` with `id bigint generated by default as identity`, so it is a number.
          title: p.title,
          category: p.category,
          subcategory: p.subcategory,
          price: p.price,
          salePrice: p.sale_price, // Schema used snake_case? check complete_ecommerce_schema.sql
          discount: p.discount,
          imageUrl: p.image_url,
          imageUrls: p.images || [], // JSONB array
          stockQuantity: p.stock_quantity,
          viewCount: p.view_count || 0,
          cartCount: 0,
          purchaseCount: 0,
          dateAdded: p.created_at,
          status: p.status,
          description: p.description,
          sizes: p.sizes || [],
          colorName: p.color_name,
          fit: p.fit,
          occasion: p.occasion,
          fabric: p.material || p.fabric, // Handle both potential column names
          colorOptions: p.color_name ? [{ name: p.color_name, code: '#000000' }] : [], // Basic mapping for now
        }));
        setProducts(mappedProducts);
      }
    } catch (err) {
      console.error('Unexpected error fetching products:', err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    refreshProducts();

    // Real-time subscription
    const subscription = supabase
      .channel('public:products')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'products' }, (payload) => {
        console.log('Real-time product update:', payload);
        refreshProducts(); // Refresh on any change
      })
      .subscribe();

    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);

  // Save new product (INSERT)
  const saveNewProduct = async (productData: any) => {
    try {
      // Map to snake_case for Supabase
      const dbProduct = {
        title: productData.title,
        description: productData.description,
        price: productData.price || productData.mrp, // fallback
        sale_price: productData.salePrice,
        discount: productData.discount,
        category: productData.category,
        subcategory: productData.subcategory,
        stock_quantity: 100, // Default for now if not provided
        status: productData.status || 'active',
        image_url: productData.imageUrl,
        images: productData.imageUrls || [],
        sizes: productData.sizes || [],
        material: productData.material,
        color_name: productData.colorName,
        sku: productData.sku,
        barcode: productData.barcode,
        video_url: productData.videoUrl,
        meta_title: productData.metaTitle,
        meta_description: productData.metaDescription,
        tags: productData.tags,
        size_stock: productData.sizeStock, // Mapping size key to qty
        // color_code?
      };

      const { data, error } = await supabase
        .from('products')
        .insert([dbProduct])
        .select();

      if (error) {
        console.error('Error saving product:', error);
        return false;
      }

      // Real-time will update the list
      return true;
    } catch (err) {
      console.error('Error saving:', err);
      return false;
    }
  };

  // Update existing product
  const updateExistingProduct = async (product: any) => {
    try {
      const dbProduct = {
        title: product.title,
        description: product.description,
        price: product.price || product.mrp,
        sale_price: product.salePrice,
        discount: product.discount,
        category: product.category,
        subcategory: product.subcategory,
        stock_quantity: product.stockQuantity,
        status: product.status,
        image_url: product.imageUrl,
        images: product.imageUrls || [],
        sizes: product.sizes || [],
        material: product.material,
        color_name: product.colorName,
        sku: product.sku,
        barcode: product.barcode,
        video_url: product.videoUrl,
        meta_title: product.metaTitle,
        meta_description: product.metaDescription,
        tags: product.tags,
        size_stock: product.sizeStock,
      };

      const { error } = await supabase
        .from('products')
        .update(dbProduct)
        .eq('id', product.id);

      if (error) {
        console.error('Error updating product:', error);
        return false;
      }
      return true;
    } catch (err) {
      console.error('Error updating:', err);
      return false;
    }
  };

  // Update product status
  const updateStatus = async (id: number, status: 'active' | 'inactive' | 'draft') => {
    const { error } = await supabase
      .from('products')
      .update({ status })
      .eq('id', id);

    if (error) {
      console.error('Error updating status:', error);
      return false;
    }
    return true;
  };

  // Update product stock
  const updateStock = async (id: number, newStock: number) => {
    const { error } = await supabase
      .from('products')
      .update({ stock_quantity: newStock })
      .eq('id', id);

    if (error) return false;
    return true;
  };

  // Remove product
  const removeProduct = async (id: number) => {
    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('Error deleting product:', error);
      return false;
    }
    return true;
  };

  // Get products by category
  const getProductsByCategory = (category: string) => {
    const normalizedCategory = category.toLowerCase().replace(' ', '-');
    return products.filter(product => {
      const prodCat = (product.category || '').toLowerCase().replace(' ', '-');
      return prodCat === normalizedCategory;
    });
  };

  // Get active products by category
  const getActiveProductsByCategory = (category: string) => {
    const normalizedCategory = category.toLowerCase().replace(' ', '-');
    return products.filter(product => {
      const prodCat = (product.category || '').toLowerCase().replace(' ', '-');
      return prodCat === normalizedCategory &&
        product.status === 'active' &&
        product.stockQuantity > 0;
    });
  };

  const value = {
    products,
    isLoading,
    saveNewProduct,
    updateExistingProduct,
    updateStatus,
    updateStock,
    removeProduct,
    refreshProducts,
    getProductsByCategory,
    getActiveProductsByCategory,
  };

  return (
    <ProductContext.Provider value={value}>
      {children}
    </ProductContext.Provider>
  );
};

export const useProducts = () => useContext(ProductContext);
export default ProductContext; 